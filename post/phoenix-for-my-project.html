
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta name="description" content="Why I chose Phoenix LiveView over Rails, Laravel, and Next.js" />
  <meta name="author" content="Akarsh Cholapurth" />
  <title>Why I chose Phoenix LiveView over Rails, Laravel, and Next.js</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    strong { font-weight: 600 !important; }
  </style>
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-L8F5V2WRJX"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-L8F5V2WRJX');
</script>
</head>

<body class="text-black/80">
  <div class="space-y-3 p-4 my-4 lg:w-[600px] mx-auto">
    <a href="../blog.html" class="text-red-600 underline text-sm">&larr; Back to blog</a>

    <h1 class="font-semibold text-2xl text-black/80 mt-4">
      Why I chose Phoenix LiveView over Rails, Laravel, and Next.js    
    </h1>
    <p class="text-xs text-gray-500 mb-6">October 16, 2025 · by Akarsh</p>

    <div class="text-sm space-y-4">
      <p>First things first, why do we code? To solve problems in the most optimal way possible.</p>

      <p>
        For me, the number one factor is speed: both application speed and development speed.
        That’s exactly what led me to <strong><a href="https://www.phoenixframework.org/" target="_blank" class="text-red-600 underline">Phoenix LiveView</a></strong>.
      </p>

      <p>
        If I had chosen React or Next.js with Laravel, or even Inertia.js with Laravel,
        I would have had to maintain both sides of the stack, frontend and backend.
        As a solo developer, I didn’t have the time to manage state in two different places.
        I needed a solid monolithic solution that could handle everything together.
      </p>

      <p>
        So I looked into Laravel Livewire and Rails Hotwire. Both are great tools that simplify frontend work
        without depending too much on JavaScript. I even thought about going full JavaScript with Next.js,
        but I’ve never been a big fan of using JS on the backend.
      </p>

      <p>
        Rails Hotwire really caught my attention, especially because of how fast you can build an MVP with Rails.
        But I still needed background jobs, real-time updates, and two-way communication that just works.
        Those things are possible in Rails and Laravel, but they take a bit more effort to set up.
      </p>

      <p>
        Then I came across <strong>Elixir</strong> and its framework <strong>Phoenix</strong>.
        It had all the elegance of Ruby on Rails, but with far better performance.
        It came with <strong><a href="https://github.com/oban-bg/oban" target="_blank" class="text-red-600 underline">background jobs through Oban</a></strong>, a familiar and clean syntax,
        and something truly special called <strong>LiveView</strong>.
      </p>

      <p>
        LiveView feels like the perfect balance between traditional server-rendered apps and frontend-heavy frameworks.
        It’s way ahead of both Rails Hotwire and Laravel Livewire. LiveView communicates through WebSockets,
        which means real-time two-way updates without sending new requests every time something changes.
        You can still use <strong>Alpine.js</strong> or any JavaScript library you want through hooks when needed.
      </p>

      <p>
        Phoenix also integrates easily with Oban for background jobs. You can declare background jobs easily,
        and when something fails, it automatically restarts without breaking the app.
        That’s the beauty of Elixir. It’s a compiled language built on top of Erlang,
        which powers highly concurrent systems like WhatsApp and Discord.
      </p>

      <h2 class="font-semibold text-lg mt-10 mb-3">Here’s what sealed it for me:</h2>
      <ul class="list-disc ml-6 space-y-1">
        <li>I can build fast</li>
        <li>I can handle high concurrency if needed</li>
        <li>I write almost everything in one language</li>
        <li>I can write clean, readable code</li>
        <li>The compiler catches most bugs before they reach production</li>
        <li>The app is fault tolerant and rarely goes down</li>
      </ul>

      <p>
        I’m not saying Phoenix is better than Laravel, Rails, or Next.js. All of these are excellent frameworks, and I’ve personally used them to build applications. Phoenix just turned out to be the best fit for my specific use case. This is my project - <a href="https://hyperzoned.com/?ref=akarshc.com" target="_blank" class="text-red-600 underline">Hyperzoned.com</a>
      </p>

      <p>
        I don’t know who needs to hear this, but try exploring beyond what you already know.
        You might find a better and more efficient way to solve your next problem.
        After all, never stop learning.
      </p>
    </div>

    <div class="mt-16 text-sm text-gray-700">
      <p>
        Thanks for reading! You can find me on
        <a href="https://x.com/akarshcp" target="_blank" class="text-red-600 underline">X</a> or
        <a href="https://hyperzoned.com/akarsh?ref=akarshc.com" target="_blank" class="text-red-600 underline">Hyperzoned.com</a>.
      </p>
    </div>
  </div>
</body>
</html>

